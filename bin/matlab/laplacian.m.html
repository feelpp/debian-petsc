
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head> <link rel="canonical" href="http://www.mcs.anl.gov/petsc/petsc-current/bin/matlab/laplacian.m.html" />
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>laplacian</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-07-02"><meta name="DC.source" content="laplacian.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span>
   <div id="version" align=right><b>petsc-3.4.2 2013-07-02</b></div> [lambda, V, A] = laplacian(varargin)

<span class="comment">% LAPLACIAN   Sparse Negative Laplacian in 1D, 2D, or 3D</span>
<span class="comment">%</span>
<span class="comment">%    [~,~,A]=LAPLACIAN(N) generates a sparse negative 3D Laplacian matrix</span>
<span class="comment">%    with Dirichlet boundary conditions, from a rectangular cuboid regular</span>
<span class="comment">%    grid with j x k x l interior grid points if N = [j k l], using the</span>
<span class="comment">%    standard 7-point finite-difference scheme,  The grid size is always</span>
<span class="comment">%    one in all directions.</span>
<span class="comment">%</span>
<span class="comment">%    [~,~,A]=LAPLACIAN(N,B) specifies boundary conditions with a cell array</span>
<span class="comment">%    B. For example, B = {'DD' 'DN' 'P'} will Dirichlet boundary conditions</span>
<span class="comment">%    ('DD') in the x-direction, Dirichlet-Neumann conditions ('DN') in the</span>
<span class="comment">%    y-direction and period conditions ('P') in the z-direction. Possible</span>
<span class="comment">%    values for the elements of B are 'DD', 'DN', 'ND', 'NN' and 'P'.</span>
<span class="comment">%</span>
<span class="comment">%    LAMBDA = LAPLACIAN(N,B,M) or LAPLACIAN(N,M) outputs the m smallest</span>
<span class="comment">%    eigenvalues of the matrix, computed by an exact known formula, see</span>
<span class="comment">%    http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors_of_the_second_derivative</span>
<span class="comment">%    It will produce a warning if the mth eigenvalue is equal to the</span>
<span class="comment">%    (m+1)th eigenvalue. If m is absebt or zero, lambda will be empty.</span>
<span class="comment">%</span>
<span class="comment">%    [LAMBDA,V] = LAPLACIAN(N,B,M) also outputs orthonormal eigenvectors</span>
<span class="comment">%    associated with the corresponding m smallest eigenvalues.</span>
<span class="comment">%</span>
<span class="comment">%    [LAMBDA,V,A] = LAPLACIAN(N,B,M) produces a 2D or 1D negative</span>
<span class="comment">%    Laplacian matrix if the length of N and B are 2 or 1 respectively.</span>
<span class="comment">%    It uses the standard 5-point scheme for 2D, and 3-point scheme for 1D.</span>
<span class="comment">%</span>
<span class="comment">%    % Examples:</span>
<span class="comment">%    [lambda,V,A] = laplacian([100,45,55],{'DD' 'NN' 'P'}, 20);</span>
<span class="comment">%    % Everything for 3D negative Laplacian with mixed boundary conditions.</span>
<span class="comment">%    laplacian([100,45,55],{'DD' 'NN' 'P'}, 20);</span>
<span class="comment">%    % or</span>
<span class="comment">%    lambda = laplacian([100,45,55],{'DD' 'NN' 'P'}, 20);</span>
<span class="comment">%    % computes the eigenvalues only</span>
<span class="comment">%</span>
<span class="comment">%    [~,V,~] = laplacian([200 200],{'DD' 'DN'},30);</span>
<span class="comment">%    % Eigenvectors of 2D negative Laplacian with mixed boundary conditions.</span>
<span class="comment">%</span>
<span class="comment">%    [~,~,A] = laplacian(200,{'DN'},30);</span>
<span class="comment">%    % 1D negative Laplacian matrix A with mixed boundary conditions.</span>
<span class="comment">%</span>
<span class="comment">%    % Example to test if outputs correct eigenvalues and vectors:</span>
<span class="comment">%    [lambda,V,A] = laplacian([13,10,6],{'DD' 'DN' 'P'},30);</span>
<span class="comment">%    [Veig D] = eig(full(A)); lambdaeig = diag(D(1:30,1:30));</span>
<span class="comment">%    max(abs(lambda-lambdaeig))  %checking eigenvalues</span>
<span class="comment">%    subspace(V,Veig(:,1:30))    %checking the invariant subspace</span>
<span class="comment">%    subspace(V(:,1),Veig(:,1))  %checking selected eigenvectors</span>
<span class="comment">%    subspace(V(:,29:30),Veig(:,29:30)) %a multiple eigenvalue</span>
<span class="comment">%</span>
<span class="comment">%    % Example showing equivalence between laplacian.m and built-in MATLAB</span>
<span class="comment">%    % DELSQ for the 2D case. The output of the last command shall be 0.</span>
<span class="comment">%    A1 = delsq(numgrid('S',32)); % input 'S' specifies square grid.</span>
<span class="comment">%    [~,~,A2] = laplacian([30,30]);</span>
<span class="comment">%    norm(A1-A2,inf)</span>
<span class="comment">%</span>
<span class="comment">%    Class support for inputs:</span>
<span class="comment">%    N - row vector float double</span>
<span class="comment">%    B - cell array</span>
<span class="comment">%    M - scalar float double</span>
<span class="comment">%</span>
<span class="comment">%    Class support for outputs:</span>
<span class="comment">%    lambda and V  - full float double, A - sparse float double.</span>
<span class="comment">%</span>
<span class="comment">%    Note: the actual numerical entries of A fit int8 format, but only</span>
<span class="comment">%    double data class is currently (2010) supported for sparse matrices.</span>
<span class="comment">%</span>
<span class="comment">%    This program is designed to efficiently compute eigenvalues,</span>
<span class="comment">%    eigenvectors, and the sparse matrix of the (1-3)D negative Laplacian</span>
<span class="comment">%    on a rectangular grid for Dirichlet, Neumann, and Periodic boundary</span>
<span class="comment">%    conditions using tensor sums of 1D Laplacians. For more information on</span>
<span class="comment">%    tensor products, see</span>
<span class="comment">%    http://en.wikipedia.org/wiki/Kronecker_sum_of_discrete_Laplacians</span>
<span class="comment">%    For 2D case in MATLAB, see</span>
<span class="comment">%    http://www.mathworks.com/access/helpdesk/help/techdoc/ref/kron.html.</span>
<span class="comment">%</span>
<span class="comment">%    This code is a part of the BLOPEX package:</span>
<span class="comment">%    http://en.wikipedia.org/wiki/BLOPEX or directly</span>
<span class="comment">%    http://code.google.com/p/blopex/</span>

<span class="comment">%    Revision 1.1 changes: rearranged the output variables, always compute</span>
<span class="comment">%    the eigenvalues, compute eigenvectors and/or the matrix on demand only.</span>

<span class="comment">%    License: BSD</span>
<span class="comment">%    Copyright 2010-2011 Bryan C. Smith, Andrew V. Knyazev</span>
<span class="comment">%    $Revision: 1.1 $ $Date: 1-Aug-2011</span>
<span class="comment">%    Tested in MATLAB 7.11.0 (R2010b) and Octave 3.4.0.</span>

tic

<span class="comment">% Input/Output handling.</span>
<span class="keyword">if</span> nargin &gt; 3
    error(<span class="string">'BLOPEX:laplacian:TooManyInputs'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Too many input arguments.'</span>);
<span class="keyword">elseif</span> nargin == 0
    error(<span class="string">'BLOPEX:laplacian:NoInputArguments'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Must have at least one input argument.'</span>);
<span class="keyword">end</span>

<span class="keyword">if</span> nargout &gt; 3
    error(<span class="string">'BLOPEX:laplacian:TooManyOutputs'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Maximum number of outputs is 3.'</span>);
<span class="keyword">end</span>

u = varargin{1};
dim2 = size(u);
<span class="keyword">if</span> dim2(1) ~= 1
    error(<span class="string">'BLOPEX:laplacian:WrongVectorOfGridPoints'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Number of grid points must be in a row vector.'</span>)
<span class="keyword">end</span>
<span class="keyword">if</span> dim2(2) &gt; 3
    error(<span class="string">'BLOPEX:laplacian:WrongNumberOfGridPoints'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Number of grid points must be a 1, 2, or 3'</span>)
<span class="keyword">end</span>
dim=dim2(2); clear <span class="string">dim2</span>;

uint = round(u);
<span class="keyword">if</span> max(uint~=u)
    warning(<span class="string">'BLOPEX:laplacian:NonIntegerGridSize'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Grid sizes must be integers. Rounding...'</span>);
    u = uint; clear <span class="string">uint</span>
<span class="keyword">end</span>
<span class="keyword">if</span> max(u&lt;=0 )
    error(<span class="string">'BLOPEX:laplacian:NonIntegerGridSize'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Grid sizes must be positive.'</span>);
<span class="keyword">end</span>

<span class="keyword">if</span> nargin == 3
    m = varargin{3};
    B = varargin{2};
<span class="keyword">elseif</span> nargin == 2
    f = varargin{2};
    a = whos(<span class="string">'regep'</span>,<span class="string">'f'</span>);
    <span class="keyword">if</span> sum(a.class(1:4)==<span class="string">'cell'</span>) == 4
        B = f;
        m = 0;
    <span class="keyword">elseif</span> sum(a.class(1:4)==<span class="string">'doub'</span>) == 4
        <span class="keyword">if</span> dim == 1
            B = {<span class="string">'DD'</span>};
        <span class="keyword">elseif</span> dim == 2
            B = {<span class="string">'DD'</span> <span class="string">'DD'</span>};
        <span class="keyword">else</span>
            B = {<span class="string">'DD'</span> <span class="string">'DD'</span> <span class="string">'DD'</span>};
        <span class="keyword">end</span>
        m = f;
    <span class="keyword">else</span>
        error(<span class="string">'BLOPEX:laplacian:InvalidClass'</span>,<span class="keyword">...</span>
            <span class="string">'%s'</span>,<span class="string">'Second input must be either class double or a cell array.'</span>);
    <span class="keyword">end</span>
<span class="keyword">else</span>
    <span class="keyword">if</span> dim == 1
        B = {<span class="string">'DD'</span>};
    <span class="keyword">elseif</span> dim == 2
        B = {<span class="string">'DD'</span> <span class="string">'DD'</span>};
    <span class="keyword">else</span>
        B = {<span class="string">'DD'</span> <span class="string">'DD'</span> <span class="string">'DD'</span>};
    <span class="keyword">end</span>
    m = 0;
<span class="keyword">end</span>

<span class="keyword">if</span> max(size(m) - [1 1]) ~= 0
    error(<span class="string">'BLOPEX:laplacian:WrongNumberOfEigenvalues'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'The requested number of eigenvalues must be a scalar.'</span>);
<span class="keyword">end</span>

maxeigs = prod(u);
mint = round(m);
<span class="keyword">if</span> mint ~= m || mint &gt; maxeigs
    error(<span class="string">'BLOPEX:laplacian:InvalidNumberOfEigs'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Number of eigenvalues output must be a nonnegative '</span>,<span class="keyword">...</span>
        <span class="string">'integer no bigger than number of grid points.'</span>);
<span class="keyword">end</span>
m = mint;

bdryerr = 0;
a = whos(<span class="string">'regep'</span>,<span class="string">'B'</span>);
<span class="keyword">if</span> sum(a.class(1:4)==<span class="string">'cell'</span>) ~= 4 || sum(a.size == [1 dim]) ~= 2
    bdryerr = 1;
<span class="keyword">else</span>
    BB = zeros(1, 2*dim);
    <span class="keyword">for</span> i = 1:dim
        <span class="keyword">if</span> (length(B{i}) == 1)
            <span class="keyword">if</span> B{i} == <span class="string">'P'</span>
                BB(i) = 3;
                BB(i + dim) = 3;
            <span class="keyword">else</span>
                bdryerr = 1;
            <span class="keyword">end</span>
        <span class="keyword">elseif</span> (length(B{i}) == 2)
            <span class="keyword">if</span> B{i}(1) == <span class="string">'D'</span>
                BB(i) = 1;
            <span class="keyword">elseif</span> B{i}(1) == <span class="string">'N'</span>
                BB(i) = 2;
            <span class="keyword">else</span>
                bdryerr = 1;
            <span class="keyword">end</span>
            <span class="keyword">if</span> B{i}(2) == <span class="string">'D'</span>
                BB(i + dim) = 1;
            <span class="keyword">elseif</span> B{i}(2) == <span class="string">'N'</span>
                BB(i + dim) = 2;
            <span class="keyword">else</span>
                bdryerr = 1;
            <span class="keyword">end</span>
        <span class="keyword">else</span>
            bdryerr = 1;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="keyword">if</span> bdryerr == 1
    error(<span class="string">'BLOPEX:laplacian:InvalidBdryConds'</span>,<span class="keyword">...</span>
        <span class="string">'%s'</span>,<span class="string">'Boundary conditions must be a cell of length 3 for 3D, 2'</span>,<span class="keyword">...</span>
        <span class="string">' for 2D, 1 for 1D, with values ''DD'', ''DN'', ''ND'', ''NN'''</span>,<span class="keyword">...</span>
        <span class="string">', or ''P''.'</span>);
<span class="keyword">end</span>

<span class="comment">% Set the component matrices. SPDIAGS converts int8 into double anyway.</span>
e1 = ones(u(1),1); <span class="comment">%e1 = ones(u(1),1,'int8');</span>
<span class="keyword">if</span> dim &gt; 1
    e2 = ones(u(2),1);
<span class="keyword">end</span>
<span class="keyword">if</span> dim &gt; 2
    e3 = ones(u(3),1);
<span class="keyword">end</span>

<span class="comment">% Calculate m smallest exact eigenvalues.</span>
<span class="keyword">if</span> m &gt; 0
    <span class="keyword">if</span> (BB(1) == 1) &amp;&amp; (BB(1+dim) == 1)
        a1 = pi/2/(u(1)+1);
        N = (1:u(1))';
    <span class="keyword">elseif</span> (BB(1) == 2) &amp;&amp; (BB(1+dim) == 2)
        a1 = pi/2/u(1);
        N = (0:(u(1)-1))';
    <span class="keyword">elseif</span> ((BB(1) == 1) &amp;&amp; (BB(1+dim) == 2)) || ((BB(1) == 2)<span class="keyword">...</span>
            &amp;&amp; (BB(1+dim) == 1))
        a1 = pi/4/(u(1)+0.5);
        N = 2*(1:u(1))' - 1;
    <span class="keyword">else</span>
        a1 = pi/u(1);
        N = floor((1:u(1))/2)';
    <span class="keyword">end</span>

    lambda1 = 4*sin(a1*N).^2;

    <span class="keyword">if</span> dim &gt; 1
        <span class="keyword">if</span> (BB(2) == 1) &amp;&amp; (BB(2+dim) == 1)
            a2 = pi/2/(u(2)+1);
            N = (1:u(2))';
        <span class="keyword">elseif</span> (BB(2) == 2) &amp;&amp; (BB(2+dim) == 2)
            a2 = pi/2/u(2);
            N = (0:(u(2)-1))';
        <span class="keyword">elseif</span> ((BB(2) == 1) &amp;&amp; (BB(2+dim) == 2)) || ((BB(2) == 2)<span class="keyword">...</span>
                &amp;&amp; (BB(2+dim) == 1))
            a2 = pi/4/(u(2)+0.5);
            N = 2*(1:u(2))' - 1;
        <span class="keyword">else</span>
            a2 = pi/u(2);
            N = floor((1:u(2))/2)';
        <span class="keyword">end</span>
        lambda2 = 4*sin(a2*N).^2;
    <span class="keyword">else</span>
        lambda2 = 0;
    <span class="keyword">end</span>

    <span class="keyword">if</span> dim &gt; 2
        <span class="keyword">if</span> (BB(3) == 1) &amp;&amp; (BB(6) == 1)
            a3 = pi/2/(u(3)+1);
            N = (1:u(3))';
        <span class="keyword">elseif</span> (BB(3) == 2) &amp;&amp; (BB(6) == 2)
            a3 = pi/2/u(3);
            N = (0:(u(3)-1))';
        <span class="keyword">elseif</span> ((BB(3) == 1) &amp;&amp; (BB(6) == 2)) || ((BB(3) == 2)<span class="keyword">...</span>
                &amp;&amp; (BB(6) == 1))
            a3 = pi/4/(u(3)+0.5);
            N = 2*(1:u(3))' - 1;
        <span class="keyword">else</span>
            a3 = pi/u(3);
            N = floor((1:u(3))/2)';
        <span class="keyword">end</span>
        lambda3 = 4*sin(a3*N).^2;
    <span class="keyword">else</span>
        lambda3 = 0;
    <span class="keyword">end</span>

    <span class="keyword">if</span> dim == 1
        lambda = lambda1;
    <span class="keyword">elseif</span> dim == 2
        lambda = kron(e2,lambda1) + kron(lambda2, e1);
    <span class="keyword">else</span>
        lambda = kron(e3,kron(e2,lambda1)) + kron(e3,kron(lambda2,e1))<span class="keyword">...</span>
            + kron(lambda3,kron(e2,e1));
    <span class="keyword">end</span>
    [lambda, p] = sort(lambda);
    <span class="keyword">if</span> m &lt; maxeigs - 0.1
        w = lambda(m+1);
    <span class="keyword">else</span>
        w = inf;
    <span class="keyword">end</span>
    lambda = lambda(1:m);
    p = p(1:m)';
<span class="keyword">else</span>
    lambda = [];
<span class="keyword">end</span>

V = [];
<span class="keyword">if</span> nargout &gt; 1 &amp;&amp; m &gt; 0 <span class="comment">% Calculate eigenvectors if specified in output.</span>

    p1 = mod(p-1,u(1))+1;

    <span class="keyword">if</span> (BB(1) == 1) &amp;&amp; (BB(1+dim) == 1)
        V1 = sin(kron((1:u(1))'*(pi/(u(1)+1)),p1))*(2/(u(1)+1))^0.5;
    <span class="keyword">elseif</span> (BB(1) == 2) &amp;&amp; (BB(1+dim) == 2)
        V1 = cos(kron((0.5:1:u(1)-0.5)'*(pi/u(1)),p1-1))*(2/u(1))^0.5;
        V1(:,p1==1) = 1/u(1)^0.5;
    <span class="keyword">elseif</span> ((BB(1) == 1) &amp;&amp; (BB(1+dim) == 2))
        V1 = sin(kron((1:u(1))'*(pi/2/(u(1)+0.5)),2*p1 - 1))<span class="keyword">...</span>
            *(2/(u(1)+0.5))^0.5;
    <span class="keyword">elseif</span> ((BB(1) == 2) &amp;&amp; (BB(1+dim) == 1))
        V1 = cos(kron((0.5:1:u(1)-0.5)'*(pi/2/(u(1)+0.5)),2*p1 - 1))<span class="keyword">...</span>
            *(2/(u(1)+0.5))^0.5;
    <span class="keyword">else</span>
        V1 = zeros(u(1),m);
        a = (0.5:1:u(1)-0.5)';
        V1(:,mod(p1,2)==1) = cos(a*(pi/u(1)*(p1(mod(p1,2)==1)-1)))<span class="keyword">...</span>
            *(2/u(1))^0.5;
        pp = p1(mod(p1,2)==0);
        <span class="keyword">if</span> ~isempty(pp)
            V1(:,mod(p1,2)==0) = sin(a*(pi/u(1)*p1(mod(p1,2)==0)))<span class="keyword">...</span>
                *(2/u(1))^0.5;
        <span class="keyword">end</span>
        V1(:,p1==1) = 1/u(1)^0.5;
        <span class="keyword">if</span> mod(u(1),2) == 0
            V1(:,p1==u(1)) = V1(:,p1==u(1))/2^0.5;
        <span class="keyword">end</span>
    <span class="keyword">end</span>


    <span class="keyword">if</span> dim &gt; 1
        p2 = mod(p-p1,u(1)*u(2));
        p3 = (p - p2 - p1)/(u(1)*u(2)) + 1;
        p2 = p2/u(1) + 1;
        <span class="keyword">if</span> (BB(2) == 1) &amp;&amp; (BB(2+dim) == 1)
            V2 = sin(kron((1:u(2))'*(pi/(u(2)+1)),p2))*(2/(u(2)+1))^0.5;
        <span class="keyword">elseif</span> (BB(2) == 2) &amp;&amp; (BB(2+dim) == 2)
            V2 = cos(kron((0.5:1:u(2)-0.5)'*(pi/u(2)),p2-1))*(2/u(2))^0.5;
            V2(:,p2==1) = 1/u(2)^0.5;
        <span class="keyword">elseif</span> ((BB(2) == 1) &amp;&amp; (BB(2+dim) == 2))
            V2 = sin(kron((1:u(2))'*(pi/2/(u(2)+0.5)),2*p2 - 1))<span class="keyword">...</span>
                *(2/(u(2)+0.5))^0.5;
        <span class="keyword">elseif</span> ((BB(2) == 2) &amp;&amp; (BB(2+dim) == 1))
            V2 = cos(kron((0.5:1:u(2)-0.5)'*(pi/2/(u(2)+0.5)),2*p2 - 1))<span class="keyword">...</span>
                *(2/(u(2)+0.5))^0.5;
        <span class="keyword">else</span>
            V2 = zeros(u(2),m);
            a = (0.5:1:u(2)-0.5)';
            V2(:,mod(p2,2)==1) = cos(a*(pi/u(2)*(p2(mod(p2,2)==1)-1)))<span class="keyword">...</span>
                *(2/u(2))^0.5;
            pp = p2(mod(p2,2)==0);
            <span class="keyword">if</span> ~isempty(pp)
                V2(:,mod(p2,2)==0) = sin(a*(pi/u(2)*p2(mod(p2,2)==0)))<span class="keyword">...</span>
                    *(2/u(2))^0.5;
            <span class="keyword">end</span>
            V2(:,p2==1) = 1/u(2)^0.5;
            <span class="keyword">if</span> mod(u(2),2) == 0
                V2(:,p2==u(2)) = V2(:,p2==u(2))/2^0.5;
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">else</span>
        V2 = ones(1,m);
    <span class="keyword">end</span>

    <span class="keyword">if</span> dim &gt; 2
        <span class="keyword">if</span> (BB(3) == 1) &amp;&amp; (BB(3+dim) == 1)
            V3 = sin(kron((1:u(3))'*(pi/(u(3)+1)),p3))*(2/(u(3)+1))^0.5;
        <span class="keyword">elseif</span> (BB(3) == 2) &amp;&amp; (BB(3+dim) == 2)
            V3 = cos(kron((0.5:1:u(3)-0.5)'*(pi/u(3)),p3-1))*(2/u(3))^0.5;
            V3(:,p3==1) = 1/u(3)^0.5;
        <span class="keyword">elseif</span> ((BB(3) == 1) &amp;&amp; (BB(3+dim) == 2))
            V3 = sin(kron((1:u(3))'*(pi/2/(u(3)+0.5)),2*p3 - 1))<span class="keyword">...</span>
                *(2/(u(3)+0.5))^0.5;
        <span class="keyword">elseif</span> ((BB(3) == 2) &amp;&amp; (BB(3+dim) == 1))
            V3 = cos(kron((0.5:1:u(3)-0.5)'*(pi/2/(u(3)+0.5)),2*p3 - 1))<span class="keyword">...</span>
                *(2/(u(3)+0.5))^0.5;
        <span class="keyword">else</span>
            V3 = zeros(u(3),m);
            a = (0.5:1:u(3)-0.5)';
            V3(:,mod(p3,2)==1) = cos(a*(pi/u(3)*(p3(mod(p3,2)==1)-1)))<span class="keyword">...</span>
                *(2/u(3))^0.5;
            pp = p1(mod(p3,2)==0);
            <span class="keyword">if</span> ~isempty(pp)
                V3(:,mod(p3,2)==0) = sin(a*(pi/u(3)*p3(mod(p3,2)==0)))<span class="keyword">...</span>
                    *(2/u(3))^0.5;
            <span class="keyword">end</span>
            V3(:,p3==1) = 1/u(3)^0.5;
            <span class="keyword">if</span> mod(u(3),2) == 0
                V3(:,p3==u(3)) = V3(:,p3==u(3))/2^0.5;
            <span class="keyword">end</span>

        <span class="keyword">end</span>
    <span class="keyword">else</span>
        V3 = ones(1,m);
    <span class="keyword">end</span>

    <span class="keyword">if</span> dim == 1
        V = V1;
    <span class="keyword">elseif</span> dim == 2
        V = kron(e2,V1).*kron(V2,e1);
    <span class="keyword">else</span>
        V = kron(e3, kron(e2, V1)).*kron(e3, kron(V2, e1))<span class="keyword">...</span>
            .*kron(kron(V3,e2),e1);
    <span class="keyword">end</span>

    <span class="keyword">if</span> m ~= 0
        <span class="keyword">if</span> abs(lambda(m) - w) &lt; maxeigs*eps(<span class="string">'double'</span>)
            sprintf(<span class="string">'\n%s'</span>,<span class="string">'Warning: (m+1)th eigenvalue is  nearly equal'</span>,<span class="keyword">...</span>
                <span class="string">' to mth.'</span>)

        <span class="keyword">end</span>
    <span class="keyword">end</span>

<span class="keyword">end</span>

A = [];
<span class="keyword">if</span> nargout &gt; 2 <span class="comment">%also calulate the matrix if specified in the output</span>

    <span class="comment">% Set the component matrices. SPDIAGS converts int8 into double anyway.</span>
    <span class="comment">%    e1 = ones(u(1),1); %e1 = ones(u(1),1,'int8');</span>
    D1x = spdiags([-e1 2*e1 -e1], [-1 0 1], u(1),u(1));
    <span class="keyword">if</span> dim &gt; 1
        <span class="comment">%        e2 = ones(u(2),1);</span>
        D1y = spdiags([-e2 2*e2 -e2], [-1 0 1], u(2),u(2));
    <span class="keyword">end</span>
    <span class="keyword">if</span> dim &gt; 2
        <span class="comment">%        e3 = ones(u(3),1);</span>
        D1z = spdiags([-e3 2*e3 -e3], [-1 0 1], u(3),u(3));
    <span class="keyword">end</span>


    <span class="comment">% Set boundary conditions if other than Dirichlet.</span>
    <span class="keyword">for</span> i = 1:dim
        <span class="keyword">if</span> BB(i) == 2
            eval([<span class="string">'D1'</span> char(119 + i) <span class="string">'(1,1) = 1;'</span>])
        <span class="keyword">elseif</span> BB(i) == 3
            eval([<span class="string">'D1'</span> char(119 + i) <span class="string">'(1,'</span> num2str(u(i)) <span class="string">') = D1'</span><span class="keyword">...</span>
                char(119 + i) <span class="string">'(1,'</span> num2str(u(i)) <span class="string">') -1;'</span>]);
            eval([<span class="string">'D1'</span> char(119 + i) <span class="string">'('</span> num2str(u(i)) <span class="string">',1) = D1'</span><span class="keyword">...</span>
                char(119 + i) <span class="string">'('</span> num2str(u(i)) <span class="string">',1) -1;'</span>]);
        <span class="keyword">end</span>

        <span class="keyword">if</span> BB(i+dim) == 2
            eval([<span class="string">'D1'</span> char(119 + i)<span class="keyword">...</span>
                <span class="string">'('</span>,num2str(u(i)),<span class="string">','</span>,num2str(u(i)),<span class="string">') = 1;'</span>])
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Form A using tensor products of lower dimensional Laplacians</span>
    Ix = speye(u(1));
    <span class="keyword">if</span> dim == 1
        A = D1x;
    <span class="keyword">elseif</span> dim == 2
        Iy = speye(u(2));
        A = kron(Iy,D1x) + kron(D1y,Ix);
    <span class="keyword">elseif</span> dim == 3
        Iy = speye(u(2));
        Iz = speye(u(3));
        A = kron(Iz, kron(Iy, D1x)) + kron(Iz, kron(D1y, Ix))<span class="keyword">...</span>
            + kron(kron(D1z,Iy),Ix);
    <span class="keyword">end</span>
<span class="keyword">end</span>

disp(<span class="string">'  '</span>)
toc
<span class="keyword">if</span> ~isempty(V)
    a = whos(<span class="string">'regep'</span>,<span class="string">'V'</span>);
    disp([<span class="string">'The eigenvectors take '</span> num2str(a.bytes) <span class="string">' bytes'</span>])
<span class="keyword">end</span>
<span class="keyword">if</span>  ~isempty(A)
    a = whos(<span class="string">'regexp'</span>,<span class="string">'A'</span>);
    disp([<span class="string">'The Laplacian matrix takes '</span> num2str(a.bytes) <span class="string">' bytes'</span>])
<span class="keyword">end</span>
disp(<span class="string">'  '</span>)
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
function [lambda, V, A] = laplacian(varargin)

% LAPLACIAN   Sparse Negative Laplacian in 1D, 2D, or 3D
%
%    [~,~,A]=LAPLACIAN(N) generates a sparse negative 3D Laplacian matrix
%    with Dirichlet boundary conditions, from a rectangular cuboid regular
%    grid with j x k x l interior grid points if N = [j k l], using the
%    standard 7-point finite-difference scheme,  The grid size is always
%    one in all directions.
%
%    [~,~,A]=LAPLACIAN(N,B) specifies boundary conditions with a cell array
%    B. For example, B = {'DD' 'DN' 'P'} will Dirichlet boundary conditions
%    ('DD') in the x-direction, Dirichlet-Neumann conditions ('DN') in the
%    y-direction and period conditions ('P') in the z-direction. Possible
%    values for the elements of B are 'DD', 'DN', 'ND', 'NN' and 'P'.
%
%    LAMBDA = LAPLACIAN(N,B,M) or LAPLACIAN(N,M) outputs the m smallest
%    eigenvalues of the matrix, computed by an exact known formula, see
%    http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors_of_the_second_derivative
%    It will produce a warning if the mth eigenvalue is equal to the
%    (m+1)th eigenvalue. If m is absebt or zero, lambda will be empty.
%
%    [LAMBDA,V] = LAPLACIAN(N,B,M) also outputs orthonormal eigenvectors
%    associated with the corresponding m smallest eigenvalues.
%
%    [LAMBDA,V,A] = LAPLACIAN(N,B,M) produces a 2D or 1D negative
%    Laplacian matrix if the length of N and B are 2 or 1 respectively.
%    It uses the standard 5-point scheme for 2D, and 3-point scheme for 1D.
%
%    % Examples:
%    [lambda,V,A] = laplacian([100,45,55],{'DD' 'NN' 'P'}, 20); 
%    % Everything for 3D negative Laplacian with mixed boundary conditions.
%    laplacian([100,45,55],{'DD' 'NN' 'P'}, 20);
%    % or
%    lambda = laplacian([100,45,55],{'DD' 'NN' 'P'}, 20);
%    % computes the eigenvalues only
%
%    [~,V,~] = laplacian([200 200],{'DD' 'DN'},30);
%    % Eigenvectors of 2D negative Laplacian with mixed boundary conditions.
%
%    [~,~,A] = laplacian(200,{'DN'},30);
%    % 1D negative Laplacian matrix A with mixed boundary conditions.
%
%    % Example to test if outputs correct eigenvalues and vectors:
%    [lambda,V,A] = laplacian([13,10,6],{'DD' 'DN' 'P'},30);
%    [Veig D] = eig(full(A)); lambdaeig = diag(D(1:30,1:30));
%    max(abs(lambda-lambdaeig))  %checking eigenvalues
%    subspace(V,Veig(:,1:30))    %checking the invariant subspace
%    subspace(V(:,1),Veig(:,1))  %checking selected eigenvectors
%    subspace(V(:,29:30),Veig(:,29:30)) %a multiple eigenvalue 
%    
%    % Example showing equivalence between laplacian.m and built-in MATLAB
%    % DELSQ for the 2D case. The output of the last command shall be 0.
%    A1 = delsq(numgrid('S',32)); % input 'S' specifies square grid.
%    [~,~,A2] = laplacian([30,30]);
%    norm(A1-A2,inf)
%    
%    Class support for inputs:
%    N - row vector float double  
%    B - cell array
%    M - scalar float double 
%
%    Class support for outputs:
%    lambda and V  - full float double, A - sparse float double.
%
%    Note: the actual numerical entries of A fit int8 format, but only
%    double data class is currently (2010) supported for sparse matrices. 
%
%    This program is designed to efficiently compute eigenvalues,
%    eigenvectors, and the sparse matrix of the (1-3)D negative Laplacian
%    on a rectangular grid for Dirichlet, Neumann, and Periodic boundary
%    conditions using tensor sums of 1D Laplacians. For more information on
%    tensor products, see
%    http://en.wikipedia.org/wiki/Kronecker_sum_of_discrete_Laplacians
%    For 2D case in MATLAB, see 
%    http://www.mathworks.com/access/helpdesk/help/techdoc/ref/kron.html.
%
%    This code is a part of the BLOPEX package: 
%    http://en.wikipedia.org/wiki/BLOPEX or directly 
%    http://code.google.com/p/blopex/

%    Revision 1.1 changes: rearranged the output variables, always compute 
%    the eigenvalues, compute eigenvectors and/or the matrix on demand only.

%    License: BSD
%    Copyright 2010-2011 Bryan C. Smith, Andrew V. Knyazev
%    $Revision: 1.1 $ $Date: 1-Aug-2011
%    Tested in MATLAB 7.11.0 (R2010b) and Octave 3.4.0.

tic

% Input/Output handling.
if nargin > 3
    error('BLOPEX:laplacian:TooManyInputs',...
        '%s','Too many input arguments.');
elseif nargin == 0
    error('BLOPEX:laplacian:NoInputArguments',...
        '%s','Must have at least one input argument.');
end

if nargout > 3
    error('BLOPEX:laplacian:TooManyOutputs',...
        '%s','Maximum number of outputs is 3.');
end

u = varargin{1};
dim2 = size(u);
if dim2(1) ~= 1
    error('BLOPEX:laplacian:WrongVectorOfGridPoints',...
        '%s','Number of grid points must be in a row vector.')
end
if dim2(2) > 3
    error('BLOPEX:laplacian:WrongNumberOfGridPoints',...
        '%s','Number of grid points must be a 1, 2, or 3')
end
dim=dim2(2); clear dim2;

uint = round(u);
if max(uint~=u)
    warning('BLOPEX:laplacian:NonIntegerGridSize',...
        '%s','Grid sizes must be integers. Rounding...');
    u = uint; clear uint
end
if max(u<=0 )
    error('BLOPEX:laplacian:NonIntegerGridSize',...
        '%s','Grid sizes must be positive.');
end

if nargin == 3
    m = varargin{3};
    B = varargin{2};
elseif nargin == 2
    f = varargin{2};
    a = whos('regep','f');
    if sum(a.class(1:4)=='cell') == 4
        B = f;
        m = 0;
    elseif sum(a.class(1:4)=='doub') == 4
        if dim == 1
            B = {'DD'};
        elseif dim == 2
            B = {'DD' 'DD'};
        else
            B = {'DD' 'DD' 'DD'};
        end
        m = f;
    else
        error('BLOPEX:laplacian:InvalidClass',...
            '%s','Second input must be either class double or a cell array.');
    end
else
    if dim == 1
        B = {'DD'};
    elseif dim == 2
        B = {'DD' 'DD'};
    else
        B = {'DD' 'DD' 'DD'};
    end
    m = 0;
end

if max(size(m) - [1 1]) ~= 0
    error('BLOPEX:laplacian:WrongNumberOfEigenvalues',...
        '%s','The requested number of eigenvalues must be a scalar.');
end

maxeigs = prod(u);
mint = round(m);
if mint ~= m || mint > maxeigs
    error('BLOPEX:laplacian:InvalidNumberOfEigs',...
        '%s','Number of eigenvalues output must be a nonnegative ',...
        'integer no bigger than number of grid points.');
end
m = mint;

bdryerr = 0;
a = whos('regep','B');
if sum(a.class(1:4)=='cell') ~= 4 || sum(a.size == [1 dim]) ~= 2
    bdryerr = 1;
else
    BB = zeros(1, 2*dim);
    for i = 1:dim
        if (length(B{i}) == 1)
            if B{i} == 'P'
                BB(i) = 3;
                BB(i + dim) = 3;
            else
                bdryerr = 1;
            end
        elseif (length(B{i}) == 2)
            if B{i}(1) == 'D'
                BB(i) = 1;
            elseif B{i}(1) == 'N'
                BB(i) = 2;
            else
                bdryerr = 1;
            end
            if B{i}(2) == 'D'
                BB(i + dim) = 1;
            elseif B{i}(2) == 'N'
                BB(i + dim) = 2;
            else
                bdryerr = 1;
            end
        else
            bdryerr = 1;
        end
    end
end

if bdryerr == 1
    error('BLOPEX:laplacian:InvalidBdryConds',...
        '%s','Boundary conditions must be a cell of length 3 for 3D, 2',...
        ' for 2D, 1 for 1D, with values ''DD'', ''DN'', ''ND'', ''NN''',...
        ', or ''P''.');
end

% Set the component matrices. SPDIAGS converts int8 into double anyway.
e1 = ones(u(1),1); %e1 = ones(u(1),1,'int8');
if dim > 1
    e2 = ones(u(2),1);
end
if dim > 2
    e3 = ones(u(3),1);
end

% Calculate m smallest exact eigenvalues.
if m > 0
    if (BB(1) == 1) && (BB(1+dim) == 1)
        a1 = pi/2/(u(1)+1);
        N = (1:u(1))';
    elseif (BB(1) == 2) && (BB(1+dim) == 2)
        a1 = pi/2/u(1);
        N = (0:(u(1)-1))';
    elseif ((BB(1) == 1) && (BB(1+dim) == 2)) || ((BB(1) == 2)...
            && (BB(1+dim) == 1))
        a1 = pi/4/(u(1)+0.5);
        N = 2*(1:u(1))' - 1;
    else
        a1 = pi/u(1);
        N = floor((1:u(1))/2)';
    end
    
    lambda1 = 4*sin(a1*N).^2;
    
    if dim > 1
        if (BB(2) == 1) && (BB(2+dim) == 1)
            a2 = pi/2/(u(2)+1);
            N = (1:u(2))';
        elseif (BB(2) == 2) && (BB(2+dim) == 2)
            a2 = pi/2/u(2);
            N = (0:(u(2)-1))';
        elseif ((BB(2) == 1) && (BB(2+dim) == 2)) || ((BB(2) == 2)...
                && (BB(2+dim) == 1))
            a2 = pi/4/(u(2)+0.5);
            N = 2*(1:u(2))' - 1;
        else
            a2 = pi/u(2);
            N = floor((1:u(2))/2)';
        end
        lambda2 = 4*sin(a2*N).^2;
    else
        lambda2 = 0;
    end
    
    if dim > 2
        if (BB(3) == 1) && (BB(6) == 1)
            a3 = pi/2/(u(3)+1);
            N = (1:u(3))';
        elseif (BB(3) == 2) && (BB(6) == 2)
            a3 = pi/2/u(3);
            N = (0:(u(3)-1))';
        elseif ((BB(3) == 1) && (BB(6) == 2)) || ((BB(3) == 2)...
                && (BB(6) == 1))
            a3 = pi/4/(u(3)+0.5);
            N = 2*(1:u(3))' - 1;
        else
            a3 = pi/u(3);
            N = floor((1:u(3))/2)';
        end
        lambda3 = 4*sin(a3*N).^2;
    else
        lambda3 = 0;
    end
    
    if dim == 1
        lambda = lambda1;
    elseif dim == 2
        lambda = kron(e2,lambda1) + kron(lambda2, e1);
    else
        lambda = kron(e3,kron(e2,lambda1)) + kron(e3,kron(lambda2,e1))...
            + kron(lambda3,kron(e2,e1));
    end
    [lambda, p] = sort(lambda);
    if m < maxeigs - 0.1
        w = lambda(m+1);
    else
        w = inf;
    end
    lambda = lambda(1:m);
    p = p(1:m)';
else
    lambda = [];
end

V = []; 
if nargout > 1 && m > 0 % Calculate eigenvectors if specified in output.
    
    p1 = mod(p-1,u(1))+1;
    
    if (BB(1) == 1) && (BB(1+dim) == 1)
        V1 = sin(kron((1:u(1))'*(pi/(u(1)+1)),p1))*(2/(u(1)+1))^0.5;
    elseif (BB(1) == 2) && (BB(1+dim) == 2)
        V1 = cos(kron((0.5:1:u(1)-0.5)'*(pi/u(1)),p1-1))*(2/u(1))^0.5;
        V1(:,p1==1) = 1/u(1)^0.5;
    elseif ((BB(1) == 1) && (BB(1+dim) == 2))
        V1 = sin(kron((1:u(1))'*(pi/2/(u(1)+0.5)),2*p1 - 1))...
            *(2/(u(1)+0.5))^0.5;
    elseif ((BB(1) == 2) && (BB(1+dim) == 1))
        V1 = cos(kron((0.5:1:u(1)-0.5)'*(pi/2/(u(1)+0.5)),2*p1 - 1))...
            *(2/(u(1)+0.5))^0.5;
    else
        V1 = zeros(u(1),m);
        a = (0.5:1:u(1)-0.5)';
        V1(:,mod(p1,2)==1) = cos(a*(pi/u(1)*(p1(mod(p1,2)==1)-1)))...
            *(2/u(1))^0.5;
        pp = p1(mod(p1,2)==0);
        if ~isempty(pp)
            V1(:,mod(p1,2)==0) = sin(a*(pi/u(1)*p1(mod(p1,2)==0)))...
                *(2/u(1))^0.5;
        end
        V1(:,p1==1) = 1/u(1)^0.5;
        if mod(u(1),2) == 0
            V1(:,p1==u(1)) = V1(:,p1==u(1))/2^0.5;
        end
    end
    
    
    if dim > 1
        p2 = mod(p-p1,u(1)*u(2));
        p3 = (p - p2 - p1)/(u(1)*u(2)) + 1;
        p2 = p2/u(1) + 1;
        if (BB(2) == 1) && (BB(2+dim) == 1)
            V2 = sin(kron((1:u(2))'*(pi/(u(2)+1)),p2))*(2/(u(2)+1))^0.5;
        elseif (BB(2) == 2) && (BB(2+dim) == 2)
            V2 = cos(kron((0.5:1:u(2)-0.5)'*(pi/u(2)),p2-1))*(2/u(2))^0.5;
            V2(:,p2==1) = 1/u(2)^0.5;
        elseif ((BB(2) == 1) && (BB(2+dim) == 2))
            V2 = sin(kron((1:u(2))'*(pi/2/(u(2)+0.5)),2*p2 - 1))...
                *(2/(u(2)+0.5))^0.5;
        elseif ((BB(2) == 2) && (BB(2+dim) == 1))
            V2 = cos(kron((0.5:1:u(2)-0.5)'*(pi/2/(u(2)+0.5)),2*p2 - 1))...
                *(2/(u(2)+0.5))^0.5;
        else
            V2 = zeros(u(2),m);
            a = (0.5:1:u(2)-0.5)';
            V2(:,mod(p2,2)==1) = cos(a*(pi/u(2)*(p2(mod(p2,2)==1)-1)))...
                *(2/u(2))^0.5;
            pp = p2(mod(p2,2)==0);
            if ~isempty(pp)
                V2(:,mod(p2,2)==0) = sin(a*(pi/u(2)*p2(mod(p2,2)==0)))...
                    *(2/u(2))^0.5;
            end
            V2(:,p2==1) = 1/u(2)^0.5;
            if mod(u(2),2) == 0
                V2(:,p2==u(2)) = V2(:,p2==u(2))/2^0.5;
            end
        end
    else
        V2 = ones(1,m);
    end
    
    if dim > 2
        if (BB(3) == 1) && (BB(3+dim) == 1)
            V3 = sin(kron((1:u(3))'*(pi/(u(3)+1)),p3))*(2/(u(3)+1))^0.5;
        elseif (BB(3) == 2) && (BB(3+dim) == 2)
            V3 = cos(kron((0.5:1:u(3)-0.5)'*(pi/u(3)),p3-1))*(2/u(3))^0.5;
            V3(:,p3==1) = 1/u(3)^0.5;
        elseif ((BB(3) == 1) && (BB(3+dim) == 2))
            V3 = sin(kron((1:u(3))'*(pi/2/(u(3)+0.5)),2*p3 - 1))...
                *(2/(u(3)+0.5))^0.5;
        elseif ((BB(3) == 2) && (BB(3+dim) == 1))
            V3 = cos(kron((0.5:1:u(3)-0.5)'*(pi/2/(u(3)+0.5)),2*p3 - 1))...
                *(2/(u(3)+0.5))^0.5;
        else
            V3 = zeros(u(3),m);
            a = (0.5:1:u(3)-0.5)';
            V3(:,mod(p3,2)==1) = cos(a*(pi/u(3)*(p3(mod(p3,2)==1)-1)))...
                *(2/u(3))^0.5;
            pp = p1(mod(p3,2)==0);
            if ~isempty(pp)
                V3(:,mod(p3,2)==0) = sin(a*(pi/u(3)*p3(mod(p3,2)==0)))...
                    *(2/u(3))^0.5;
            end
            V3(:,p3==1) = 1/u(3)^0.5;
            if mod(u(3),2) == 0
                V3(:,p3==u(3)) = V3(:,p3==u(3))/2^0.5;
            end
            
        end
    else
        V3 = ones(1,m);
    end
    
    if dim == 1
        V = V1;
    elseif dim == 2
        V = kron(e2,V1).*kron(V2,e1);
    else
        V = kron(e3, kron(e2, V1)).*kron(e3, kron(V2, e1))...
            .*kron(kron(V3,e2),e1);
    end
    
    if m ~= 0
        if abs(lambda(m) - w) < maxeigs*eps('double')
            sprintf('\n%s','Warning: (m+1)th eigenvalue is  nearly equal',...
                ' to mth.')
            
        end
    end
    
end

A = [];
if nargout > 2 %also calulate the matrix if specified in the output
    
    % Set the component matrices. SPDIAGS converts int8 into double anyway.
    %    e1 = ones(u(1),1); %e1 = ones(u(1),1,'int8');
    D1x = spdiags([-e1 2*e1 -e1], [-1 0 1], u(1),u(1));
    if dim > 1
        %        e2 = ones(u(2),1);
        D1y = spdiags([-e2 2*e2 -e2], [-1 0 1], u(2),u(2));
    end
    if dim > 2
        %        e3 = ones(u(3),1);
        D1z = spdiags([-e3 2*e3 -e3], [-1 0 1], u(3),u(3));
    end
    
    
    % Set boundary conditions if other than Dirichlet.
    for i = 1:dim
        if BB(i) == 2
            eval(['D1' char(119 + i) '(1,1) = 1;'])
        elseif BB(i) == 3
            eval(['D1' char(119 + i) '(1,' num2str(u(i)) ') = D1'...
                char(119 + i) '(1,' num2str(u(i)) ') -1;']);
            eval(['D1' char(119 + i) '(' num2str(u(i)) ',1) = D1'...
                char(119 + i) '(' num2str(u(i)) ',1) -1;']);
        end
        
        if BB(i+dim) == 2
            eval(['D1' char(119 + i)...
                '(',num2str(u(i)),',',num2str(u(i)),') = 1;'])
        end
    end
    
    % Form A using tensor products of lower dimensional Laplacians
    Ix = speye(u(1));
    if dim == 1
        A = D1x;
    elseif dim == 2
        Iy = speye(u(2));
        A = kron(Iy,D1x) + kron(D1y,Ix);
    elseif dim == 3
        Iy = speye(u(2));
        Iz = speye(u(3));
        A = kron(Iz, kron(Iy, D1x)) + kron(Iz, kron(D1y, Ix))...
            + kron(kron(D1z,Iy),Ix);
    end
end

disp('  ')
toc
if ~isempty(V)
    a = whos('regep','V');
    disp(['The eigenvectors take ' num2str(a.bytes) ' bytes'])
end
if  ~isempty(A)
    a = whos('regexp','A');
    disp(['The Laplacian matrix takes ' num2str(a.bytes) ' bytes'])
end
disp('  ')


##### SOURCE END #####
--></body></html>